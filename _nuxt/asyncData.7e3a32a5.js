import{a2 as w,j as D,a3 as x,r as d,a4 as C,a5 as b,a6 as O,a as m,Z as B,a7 as H,N as M,a8 as R}from"./entry.2e2ddc9e.js";function E(...i){var h;const l=typeof i[i.length-1]=="string"?i.pop():void 0;typeof i[0]!="string"&&i.unshift(l);let[e,u,a={}]=i;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof u!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=D(),v=()=>null,_=()=>t.isHydrating?t.payload.data[e]:t.static.data[e];a.server=a.server??!0,a.default=a.default??v,a.getCachedData=a.getCachedData??_,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??x.deep;const f=()=>![null,void 0].includes(a.getCachedData(e));if(!t._asyncData[e]||!a.immediate){(h=t.payload._errors)[e]??(h[e]=null);const n=a.deep?d:C;t._asyncData[e]={data:n(a.getCachedData(e)??a.default()),pending:d(!f()),error:b(t.payload._errors,e),status:d("idle")}}const s={...t._asyncData[e]};s.refresh=s.execute=(n={})=>{if(t._asyncDataPromises[e]){if(n.dedupe===!1)return t._asyncDataPromises[e];t._asyncDataPromises[e].cancelled=!0}if((n._initial||t.isHydrating&&n._initial!==!1)&&f())return Promise.resolve(a.getCachedData(e));s.pending.value=!0,s.status.value="pending";const c=new Promise((r,o)=>{try{r(u(t))}catch(P){o(P)}}).then(r=>{if(c.cancelled)return t._asyncDataPromises[e];let o=r;a.transform&&(o=a.transform(r)),a.pick&&(o=k(o,a.pick)),t.payload.data[e]=o,s.data.value=o,s.error.value=null,s.status.value="success"}).catch(r=>{if(c.cancelled)return t._asyncDataPromises[e];s.error.value=H(r),s.data.value=M(a.default()),s.status.value="error"}).finally(()=>{c.cancelled||(s.pending.value=!1,delete t._asyncDataPromises[e])});return t._asyncDataPromises[e]=c,t._asyncDataPromises[e]};const y=()=>s.refresh({_initial:!0}),g=a.server!==!1&&t.payload.serverRendered;{const n=R();if(n&&!n._nuxtOnBeforeMountCbs){n._nuxtOnBeforeMountCbs=[];const r=n._nuxtOnBeforeMountCbs;n&&(O(()=>{r.forEach(o=>{o()}),r.splice(0,r.length)}),m(()=>r.splice(0,r.length)))}g&&t.isHydrating&&(s.error.value||f())?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):n&&(t.payload.serverRendered&&t.isHydrating||a.lazy)&&a.immediate?n._nuxtOnBeforeMountCbs.push(y):a.immediate&&y(),a.watch&&B(a.watch,()=>s.refresh());const c=t.hook("app:data:refresh",async r=>{(!r||r.includes(e))&&await s.refresh()});n&&m(c)}const p=Promise.resolve(t._asyncDataPromises[e]).then(()=>s);return Object.assign(p,s),p}async function N(i){await new Promise(e=>w(e));const l=i?Array.isArray(i)?i:[i]:void 0;await D().hooks.callHookParallel("app:data:refresh",l)}function k(i,l){const e={};for(const u of l)e[u]=i[u];return e}export{N as r,E as u};
